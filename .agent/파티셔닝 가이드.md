# MariaDB 자동 파티셔닝 구현 가이드

본 문서는 `SYS_EVENT_LOG` 및 `SYS_ACCS_LOG` 테이블의 대용량 데이터 효율적 관리를 위한 **월별 범위 파티셔닝(Monthly Range Partitioning)** 구현 및 자동화 방법을 설명합니다.

---

## 1. 개요
*   **목적**: 로그 데이터 증가에 따른 조회 성능 저하 방지 및 데이터 유지보수(오래된 데이터 삭제) 편의성 확보.
*   **전략**: 
    - `DATETIME` 타입 컬럼 기준의 `RANGE` 파티셔닝.
    - 매일 새벽 3시, 향후 2개월치 파티션 자동 생성 (Spring Scheduler).

---

## 2. [단계 1] 데이터베이스 사전 작업 (SQL)
MariaDB의 파티셔닝 제약을 극복하기 위해 기존 테이블 구조를 변경해야 합니다.

### ⚠️ 중요 제약 사항
1.  **타입 제약**: `TIMESTAMP`는 타임존 의존적이므로 파티션 함수(`TO_DAYS`) 사용이 불가합니다. 반드시 `DATETIME`으로 변경해야 합니다.
2.  **PK 제약**: 파티션 기준 컬럼(날짜)은 반드시 Primary Key의 일부여야 합니다.

### 실행 SQL
```sql
-- [주의] 테이블별로 한 줄씩 순서대로 실행하세요.

-- 1. SYS_EVENT_LOG 테이블
ALTER TABLE SYS_EVENT_LOG MODIFY COLUMN system_create_date DATETIME;
ALTER TABLE SYS_EVENT_LOG DROP PRIMARY KEY, ADD PRIMARY KEY (id, system_create_date);
ALTER TABLE SYS_EVENT_LOG PARTITION BY RANGE (TO_DAYS(system_create_date)) (
    PARTITION p202601 VALUES LESS THAN (TO_DAYS('2026-02-01'))
);

-- 2. SYS_ACCS_LOG 테이블
ALTER TABLE SYS_ACCS_LOG MODIFY COLUMN system_login_date DATETIME;
ALTER TABLE SYS_ACCS_LOG DROP PRIMARY KEY, ADD PRIMARY KEY (id, system_login_date);
ALTER TABLE SYS_ACCS_LOG PARTITION BY RANGE (TO_DAYS(system_login_date)) (
    PARTITION p202601 VALUES LESS THAN (TO_DAYS('2026-02-01'))
);
```

---

## 3. [단계 2] 백엔드 구현 (Java/MyBatis)

### 3.1 MyBatis Mapper Interface & XML
파티션 정보를 조회하고 새 파티션을 추가하는 SQL 정의.

*   **위치**: `Core-lib/../db/DbPartitionMapper.java`, `db/DbPartitionMapper.xml`

```xml
<!-- 파티션 존재 여부 조회 -->
<select id="selectPartitions" resultType="string">
    SELECT PARTITION_NAME 
    FROM INFORMATION_SCHEMA.PARTITIONS 
    WHERE TABLE_SCHEMA = DATABASE() 
      AND TABLE_NAME = #{tableName} 
      AND PARTITION_NAME IS NOT NULL
</select>

<!-- 새 파티션 추가 (DDL) -->
<update id="addPartition">
    ALTER TABLE ${tableName} ADD PARTITION (
        PARTITION ${partitionName} VALUES LESS THAN (TO_DAYS(#{lessThanValue}))
    )
</update>
```

### 3.2 자동 주입 인터셉터 (QueryTypeInterceptor)
`TIMESTAMP`에서 `DATETIME`으로 변경되면서 사라진 DB의 자동 시간 입력을 어플리케이션 레이어에서 처리합니다.

*   **수정 사항**: `INSERT` 시 로그인 여부와 관계없이 `system_create_date` 수동 주입 로직 추가.

### 3.3 파티션 유지보수 서비스 (DbPartitionService)
매일 스케줄러를 통해 미래 파티션을 생성합니다.

*   **핵심 로직**:
    ```java
    @Scheduled(cron = "0 0 3 * * *") // 매일 새벽 3시
    public void maintainPartitions() {
        for (String table : tables) {
            ensureFuturePartitions(table);
        }
    }
    ```

---

## 4. [단계 3] 설정 (Configuration)

### 4.1 스케줄러 활성화
스케줄러는 중복 실행 방지를 위해 **Management System** 한 곳에서만 동작하도록 설정합니다.

*   **Main Class**: `@EnableScheduling` 어노테이션 추가.
*   **application.yml**:
    ```yaml
    db:
      partition:
        maintenance:
          enabled: true  # Management 서버만 true로 설정
    ```

---

## 5. 관리 및 모니터링

### 파티션 생성 확인 쿼리
```sql
SELECT 
    TABLE_NAME, 
    PARTITION_NAME, 
    PARTITION_DESCRIPTION AS '기준일(LESS_THAN)', 
    TABLE_ROWS AS '데이터수'
FROM INFORMATION_SCHEMA.PARTITIONS 
WHERE TABLE_NAME IN ('SYS_EVENT_LOG', 'SYS_ACCS_LOG')
ORDER BY TABLE_NAME, PARTITION_NAME;
```

---

## 6. 주의 사항
1.  **초기 파티션 필수**: 파티션이 전혀 없는 테이블에는 `ADD PARTITION` 명령이 작동하지 않습니다. 반드시 최초 1회는 `ALTER TABLE ... PARTITION BY RANGE`로 파티션화해야 합니다.
2.  **컬럼명 일치**: `SYS_EVENT_LOG`는 `system_create_date`, `SYS_ACCS_LOG`는 `system_login_date`를 기준으로 합니다.
3.  **빌드**: `core-lib` 수정 시 반드시 `./deploy-core-lib.sh`를 실행하고 각 서비스를 재시작해야 합니다.
